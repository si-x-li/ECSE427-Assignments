#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "shell.h"
#include "interpreter.h"

int main() {
	// Keep track of errors
	int err = 0;

	// Print welcome prompt
	printf("Welcome to the %s shell!\nVersion 1.0 Created January 2019\n",
	       SHELL_NAME);

	while(err == 0) {
		err = prompt_command();
		switch(err) {
			case -3: printf("Bye!\n"); break;
			case -4: printf("The specified variable could not be printed\n");
			case -5: printf("The specified script could not be executed\n");
			case -6: printf("The specified variable could not be set\n");
			case -1:
			case -2:
			case -7:
			case -8:
			case -9:
			case -10:
			case -11:
			default: err = 0; break;
		}
	}

	exit(err);
}

/* ----------------------------------------------------------------------------
 * @brief Prompts the user for an input. 
 * @return int - status code. The status code could be generated by the 
 *               interpreter or this function. Visit interpreter.c for the most
 *               up-to-date version of interpreter status codes. -1 to -9 are
 *               reserved for the interpreter.
 *                  0  - No error
 *                 -1  - Input array of strings is null
 *                 -2  - Invalid number of words from interpreter
 *                 -3  - Exit
 *                 -4  - Variable could not be printed
 *                 -5  - Script could not be executed
 *                 -6  - Variable could not be set
 *                 -7  - FUTURE USE - Reserved for interpreter
 *                 -8  - FUTURE USE - Reserved for interpreter
 *                 -9  - FUTURE USE - Reserved for interpreter
 *                 -10 - No input detected from user
 *                 -11 - Invalid number of words from this function 
 * ----------------------------------------------------------------------------
 */
int prompt_command() {
	int num_of_words;
	int trimmed_cmd_len;
	char cmd[MAX_CMD_LENGTH];
	char trimmed_cmd[MAX_CMD_LENGTH];
	char *words[MAX_CMD_LENGTH];

	// Prompt user for input
	printf("$");
	fgets(cmd, MAX_CMD_LENGTH, stdin);

	// Obtain the trimmed command, i.e. trailing and leading whitespaces
	// removed from the input string
	trimmed_cmd_len = trim(cmd, strnlen(cmd, MAX_CMD_LENGTH), trimmed_cmd);

	// Send user input to the parser function and return the status code
	if (trimmed_cmd_len > 0) {
		num_of_words = parser(trimmed_cmd, words);
	} else {
		// User entered an empty command
		num_of_words = 0;
	}

	if (num_of_words > 0) {
		return interpret(words, num_of_words);
	} else if (num_of_words == 0) {
		return -10;
	} else {
		return -11;
	}
}

/* ----------------------------------------------------------------------------
 * @brief Removes leading and trailing whitespaces from an input string.
 * @param input  - str          A string to trim
 *        input  - str_size     Length of the input string
 *        output - trimmed_str  A string with leading and trailing whitespaces
 *                              removed.
 * @return int - length of trimmed string or status code
 *               >= 0 - Length of trimmed string
 *                 -1 - Input string is null
 *                 -2 - Invalid size of string
 *                 -3 - Output string is null
 * ----------------------------------------------------------------------------
 */
int trim(const char *str, int str_size, char *trimmed_str) {
	int i = 0;
	int start = 0;
	int end = str_size - 1;

	// Check if the input string is null
	if (!str) {
		return -1;
	}

	// Check if input string has a valid size
	if (str_size == 0) {
		return -2;
	}

	// Check if output has a valid pointer
	if (!trimmed_str) {
		return -3;
	}

	// Check for leading whitespace
	for (i = start; i < str_size; i++) {
		if (str[i] != ' ') {
			start = i;
			break;
		}
	}

	// Check for trailing whitespace
	for (i = end; i >= 0; i--) {
		if (str[i] != ' ' && str[i] != '\n') {
			end = i + 1;
			break;
		}
	}

	// Obtain substring
	strncpy(trimmed_str, str + start, (end - start));
	trimmed_str[end - start] = '\0';

//	printf("Start: %d end: %d\n", start, end);

	// Return size of substring
	return strnlen(trimmed_str, MAX_CMD_LENGTH);
}

/* ----------------------------------------------------------------------------
 * @brief Parses a trimmed string and breaks it into an array of words using
 *        strtok from the string.h library.
 * @param input  - str       A trimmed string
 *        output - words     An array of strings obtained by breaking apart 
 *                           user input
 * @return int - number of words found or status code
 *               >= 0 - 
 *                 -1 - Input string is null
 *                 -2 - Output words is null
 * ----------------------------------------------------------------------------
 */
int parser(const char *str, char *words[MAX_CMD_LENGTH]) {
	char str_copy[MAX_CMD_LENGTH];
	char *word;
	int i = 0;

	// Check if input string is null
	if (!str) {
		return -1;
	}

	// Check if output has a valid pointer
	if (!words) {
		return -2;
	}

	// Copy user input since strtok is destructive
	strncpy(str_copy, str, MAX_CMD_LENGTH);

	// Split user input using space as a token delimiter
	word = strtok(str_copy, " ");
	while (word != NULL) {
		words[i] = word;
		word = strtok(NULL, " ");
		i++;
	}

	// Returns number of words found
	return i;
}
