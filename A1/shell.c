/* ----------------------------------------------------------------------------
 * @file SHELL.C
 * @author Si Xun Li - 260674916
 * @version 1.0
 * @brief This file serves as entry point to the shell and handles status
 *        codes thrown back from the interpreter. It also handles user inputs
 *        and basic parsing.
 * ----------------------------------------------------------------------------
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "shell.h"
#include "interpreter.h"

/*
 * Local functions
 */
void automated_test(linked_list *list);

int main() {
	// Serves as the shell's memory
 	linked_list *list = (linked_list *) malloc(sizeof(linked_list));
	list->size = 0;

	// Keep track of errors
	int err = 0;

	// Print welcome prompt
	printf("Welcome to the %s shell!\nVersion %s Created January 2019\n",
	       SHELL_NAME, SHELL_VERSION);

	while(err == 0) {
		err = prompt_command(list);
		err = handle_error(err);

		// Clear line
		printf("\n");
	}
}

/* ----------------------------------------------------------------------------
 * @brief Prompts the user for an input. 
 * @return int - status code. The status code could be generated by the 
 *               interpreter or this function. Visit interpreter.c for the most
 *               up-to-date version of interpreter status codes. -1 to -19 are
 *               reserved for the interpreter.
 *                  0  - No error
 *                 -1  - Input array of strings is null
 *                 -2  - Invalid number of words
 *                 -3  - Exit
 *                 -4  - Variable could not be printed
 *                 -5  - Script could not be executed
 *                 -6  - Variable could not be set
 *                 -7  - Undefined command
 *                 -8  - FUTURE USE - Reserved for interpreter
 *                 -9  - FUTURE USE - Reserved for interpreter
 *                 ...
 *                 -20 - No input detected from user
 *                 -21 - Invalid number of words from this function 
 * ----------------------------------------------------------------------------
 */
int prompt_command(linked_list *list) {
	int num_of_words;
	int trimmed_cmd_len;
	char *cmd = (char *) malloc(MAX_CMD_LENGTH);
	char trimmed_cmd[MAX_CMD_LENGTH];
	char *words[MAX_CMD_LENGTH];

	// Prompt user for input
	printf("$");
	fgets(cmd, MAX_CMD_LENGTH, stdin);

	// Obtain the trimmed command, i.e. trailing and leading whitespaces
	// removed from the input string
	trimmed_cmd_len = trim(cmd, strlen(cmd), trimmed_cmd);
	free(cmd);

	// Send user input to the parser function and return the status code
	if (trimmed_cmd_len > 0) {
		num_of_words = parser(trimmed_cmd, words);
	} else {
		// User entered an empty command
		num_of_words = 0;
	}

	if (num_of_words > 0) {
		return interpret(list, words, num_of_words);
	} else if (num_of_words == 0) {
		return -20;
	} else {
		return -21;
	}
}

/* ----------------------------------------------------------------------------
 * @brief Removes leading and trailing whitespaces from an input string.
 * @param input  - str          A string to trim
 *        input  - str_size     Length of the input string
 *        output - trimmed_str  A string with leading and trailing whitespaces
 *                              removed.
 * @return int - length of trimmed string or status code
 *               >= 0 - Length of trimmed string
 *                 -1 - Input string is null
 *                 -2 - Invalid size of string
 *                 -3 - Output string is null
 * ----------------------------------------------------------------------------
 */
int trim(const char *str, int str_size, char *trimmed_str) {
	int i = 0;
	int start = 0;
	int end = str_size - 1;

	// Check if the input string is null
	if (!str) {
		return -1;
	}

	// Check if input string has a valid size
	if (str_size == 0) {
		return -2;
	}

	// Check if output has a valid pointer
	if (!trimmed_str) {
		return -3;
	}

	// Check for leading whitespace
	for (i = start; i < str_size; i++) {
		if (str[i] != ' ') {
			start = i;
			break;
		}
	}

	// Check for trailing whitespace
	for (i = end; i >= 0; i--) {
		if (str[i] != ' ' && str[i] != '\n') {
			end = i + 1;
			break;
		}
	}

	// Obtain substring
	strncpy(trimmed_str, str + start, (end - start));
	trimmed_str[end - start] = '\0';

	// Return size of substring
	return strlen(trimmed_str);
}

/* ----------------------------------------------------------------------------
 * @brief Parses a trimmed string and breaks it into an array of words using
 *        strtok from the string.h library.
 * @param input  - str       A trimmed string
 *        output - words     An array of strings obtained by breaking apart 
 *                           user input
 * @return int - number of words found or status code
 *               >= 0 - 
 *                 -1 - Input string is null
 *                 -2 - Output words is null
 * ----------------------------------------------------------------------------
 */
int parser(const char *str, char *words[MAX_CMD_LENGTH]) {
	char str_copy[MAX_CMD_LENGTH];
	char *word;
	int i = 0;

	// Check if input string is null
	if (!str) {
		return -1;
	}

	// Check if output has a valid pointer
	if (!words) {
		return -2;
	}

	// Copy user input since strtok is destructive
	strncpy(str_copy, str, MAX_CMD_LENGTH);

	// Split user input using space as a token delimiter
	word = strtok(str_copy, " ");
	while (word != NULL) {
		words[i] = word;
		word = strtok(NULL, " ");
		i++;
	}

	// Returns number of words found
	return i;
}

/* ----------------------------------------------------------------------------
 * @brief Handles error returned by the entire system.
 * @param input  - err A status/error code
 * @return int - The modified error code
 * ----------------------------------------------------------------------------
 */
int handle_error(int err) {
	switch(err) {
		case -3: printf("Bye!\n"); break;
		case -4: printf("Variable does not exist!\n"); break;
		case -5: printf("Script not found!\n"); break;
		case -6: printf("Variable could not be set!\n"); break;
		case -7: break;
		case -1:
		case -2:
		case -20:
		case -21:
		default: break;
	}
	// Exit
	if (err != -3) {
		err = 0;
	} else {
		exit(err);
	}
	return err;
}

/* ----------------------------------------------------------------------------
 *                    SECTION TO BE REMOVED WHEN SUBMITTING
 * ----------------------------------------------------------------------------
 */
void automated_test(linked_list *list) {
	char output_value[MAX_CMD_LENGTH];
	printf("Inserted %d\n", insert_first(list, "hello", "last"));
	printf("Update %d\n", update_value_by_key(list, "hello", "first"));
	print_traversal(list);
	printf("Inserted %d\n", insert_first(list, "abc", "123"));
	print_traversal(list);
	printf("Inserted %d\n", insert_first(list, "g", "456"));
	print_traversal(list);
	printf("Inserted at index %d\n", insert(list, 3, "d", "55"));
	print_traversal(list);
	printf("Inserted at index %d\n", insert(list, 0, "e", "535"));
	print_traversal(list);
	printf("Inserted at index %d\n", insert(list, 1, "f", "77"));
	print_traversal(list);
	printf("Inserted at index %d\n", insert(list, list->size, "h", NULL));
	printf("Inserted at index %d\n", insert(list, list->size, NULL, "h"));
	printf("Inserted at index %d\n", insert(list, 10, "h", "h"));
	printf("Inserted at index %d\n", insert(NULL, list->size, "h", "h"));
	print_traversal(list); 
	printf("List size: %d\n", list->size);
	printf("Found hello: %d\n", search(list, "hello"));
	printf("Found last: %d\n", search(list, "last"));
	printf("Found by key: %d\n", get_value_by_key(list, "hello", output_value));
	printf("Value by key: %s\n", output_value);
	printf("Found by key: %d\n", get_value_by_key(list, "134", output_value));
	if (output_value) {
		printf("Value by key: %s\n", output_value);
	}
	printf("Found by position: %d\n", get_value(list, 1, output_value));
	printf("Value by position: %s\n", output_value);
	printf("Found by position last: %d\n", get_value(list, list->size, output_value));
	printf("Value by position: %s\n", output_value);
	printf("Found by position first: %d\n", get_value(list, 0, output_value));
	printf("Value by position: %s\n", output_value);
	print_traversal(list);
	printf("Update value by key: %d\n", update_value_by_key(list, "d", "353"));
	print_traversal(list);
	printf("Update value by inexistant key: %d\n", 
	       update_value_by_key(list, "a", "355"));
	printf("Remove node by key: %d\n", remove_node_by_key(list, "e"));
	print_traversal(list);
	printf("Remove node by key: %d\n", remove_node_by_key(list, "d"));
	print_traversal(list);
	printf("Remove node by key: %d\n", remove_node_by_key(list, "abc"));
	print_traversal(list);
	printf("List size: %d\n", list->size);
}
