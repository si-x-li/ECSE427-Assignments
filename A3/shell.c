/* ----------------------------------------------------------------------------
 * @file SHELL.C
 * @author Si Xun Li - 260674916
 * @version 2.0
 * @brief This file serves as entry point to the shell and handles status
 *        codes thrown back from the interpreter. It also handles user inputs
 *        and basic parsing.
 * ----------------------------------------------------------------------------
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "interpreter.h"
#include "shell.h"

/* ----------------------------------------------------------------------------
 * @brief Prompts the user for an input. 
 * @return int - status code. The status code could be generated by the 
 *               interpreter or this function. Visit interpreter.c for the most
 *               up-to-date version of interpreter status codes. -1 to -19 are
 *               reserved for the interpreter.
 *                  0  - No error
 *                 -1  - Input array of strings is null
 *                 -2  - Invalid number of words
 *                 -3  - Exit
 *                 -4  - Variable could not be printed
 *                 -5  - Script could not be executed
 *                 -6  - Variable could not be set
 *                 -7  - Undefined command
 *                 -8  - FUTURE USE - Reserved for interpreter
 *                 -9  - FUTURE USE - Reserved for interpreter
 *                 ...
 *                 -20 - No input detected from user
 *                 -21 - Invalid number of words from this function 
 * ----------------------------------------------------------------------------
 */
int prompt_command() {
	int num_of_words;
	int trimmed_cmd_len;
	char cmd[MAX_CMD_LENGTH];
	char trimmed_cmd[MAX_CMD_LENGTH];
	char *words[MAX_CMD_LENGTH];

	// Prompt user for input
	printf("$");
	if (fgets(cmd, MAX_CMD_LENGTH, stdin) == NULL) {
		printf("Piping completed restoring console inputs...\n");
		stdin = fopen("/dev/tty", "rb");
		return 0;
	}

	// Obtain the trimmed command, i.e. trailing and leading whitespaces
	// removed from the input string
	trimmed_cmd_len = trim(cmd, strlen(cmd), trimmed_cmd);

	// Send user input to the parser function and return the status code
	if (trimmed_cmd_len > 0) {
		num_of_words = parser(trimmed_cmd, words);
	} else {
		// User entered an empty command
		num_of_words = 0;
	}

	if (num_of_words > 0) {
		return interpret(words, num_of_words, 0);
	} else if (num_of_words == 0) {
		return -20;
	} else {
		return -21;
	}
}

/* ----------------------------------------------------------------------------
 * @brief Removes leading and trailing whitespaces from an input string.
 * @param input  - str          A string to trim
 *        input  - str_size     Length of the input string
 *        output - trimmed_str  A string with leading and trailing whitespaces
 *                              removed.
 * @return int - length of trimmed string or status code
 *               >= 0 - Length of trimmed string
 *                 -1 - Input string is null
 *                 -2 - Invalid size of string
 *                 -3 - Output string is null
 * ----------------------------------------------------------------------------
 */
int trim(const char *str, int str_size, char *trimmed_str) {
	int i = 0;
	int start = 0;
	int end = str_size - 1;

	// Check if the input string is null
	if (!str) {
		return -1;
	}

	// Check if input string has a valid size
	if (str_size == 0) {
		return -2;
	}

	// Check if output has a valid pointer
	if (!trimmed_str) {
		return -3;
	}

	// Check for leading whitespace
	for (i = start; i < str_size; i++) {
		if (str[i] != ' ') {
			start = i;
			break;
		}
	}

	// Check for trailing whitespace
	for (i = end; i >= 0; i--) {
		if (str[i] != ' ' && str[i] != '\n') {
			end = i + 1;
			break;
		}
	}

	// Obtain substring
	strncpy(trimmed_str, str + start, (end - start));
	trimmed_str[end - start] = '\0';

	// Return size of substring
	return strlen(trimmed_str);
}

/* ----------------------------------------------------------------------------
 * @brief Parses a trimmed string and breaks it into an array of words using
 *        strtok from the string.h library.
 * @param input  - str       A trimmed string
 *        output - words     An array of strings obtained by breaking apart 
 *                           user input
 * @return int - number of words found or status code
 *               >= 0 - 
 *                 -1 - Input string is null
 *                 -2 - Output words is null
 * ----------------------------------------------------------------------------
 */
int parser(const char *str, char *words[MAX_CMD_LENGTH]) {
	char str_copy[MAX_CMD_LENGTH];
	char *word;
	int i = 0;

	// Check if input string is null
	if (!str) {
		return -1;
	}

	// Check if output has a valid pointer
	if (!words) {
		return -2;
	}

	// Copy user input since strtok is destructive
	strncpy(str_copy, str, MAX_CMD_LENGTH);

	// Split user input using space as a token delimiter
	word = strtok(str_copy, " ");
	while (word != NULL) {
		words[i] = word;
		word = strtok(NULL, " ");
		i++;
	}

	// Returns number of words found
	return i;
}

/* ----------------------------------------------------------------------------
 * @brief Handles error returned by the entire system.
 * @param input  - err A status/error code
 * @return int - The modified error code
 * ----------------------------------------------------------------------------
 */
int handle_error(int err) {
	switch(err) {
		case -3: printf("Bye!\n"); break;
		case -4: printf("Variable does not exist!\n"); break;
		case -5: printf("Script not found!\n"); break;
		case -6: printf("Variable could not be set!\n"); break;
		case -7: break;
		case -8: printf("Failed to execute concurrent scripts\n"); break;
		case -1:
		case -2:
		case -20:
		case -21:
		default: break;
	}
	// Exit
	if (err != -3) {
		err = 0;
	} else {
		exit(err);
	}
	return err;
}
